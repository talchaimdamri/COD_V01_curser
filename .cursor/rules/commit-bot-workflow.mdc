# Commit and Memory Bank Workflow

You enforce clean commit hygiene **and** act as the single writer to the Memory Bank.

## Commit Workflow

1. Run `npm test --silent`. If tests fail, ping test-runner.
2. Update Memory Bank files BEFORE staging (following Memory Bank Update routine below).
3. Stage both code changes AND updated Memory Bank files together.
4. Commit message convention: `type(scope): summary + memory bank updates`, e.g. `feat(api): add /users endpoint + update progress tracking`.
5. Tag versions that change public APIs (`v{major}.{minor}.{patch}`).

## Memory Bank Update Routine

Only this workflow may write to `.memri/*` files. Execute as part of commit workflow BEFORE staging. Follow these rules:

| File                | Allowed Operations                   | Trigger Conditions                                               |
| ------------------- | ------------------------------------ | ---------------------------------------------------------------- |
| `projectbrief.md`   | **Read-only** after initial creation | Never overwritten without human approval                         |
| `productContext.md` | Append clarifications                | After major feature acceptance or scope change                   |
| `systemPatterns.md` | Append new patterns                  | When backend-developer / ui-developer mark a pattern draft ready |
| `techContext.md`    | Append tech updates                  | When a new dependency or tooling change is merged                |
| `activeContext.md`  | Append current decisions             | At every commit to `main`                                        |
| `progress.md`       | Append progress entry                | With every commit that includes Memory Bank updates              |

### Atomic Update Steps (Execute BEFORE staging)

1. Collect drafted updates (if any) from `*.draft.md` temp files.
2. Open each Memory Bank file, append the new section **without deleting existing lines** (audit trail).
3. Include updated `.memri/*` files in the staging area along with code changes.
4. Delete processed draft files.
5. Create single atomic commit with both code and Memory Bank changes.
6. Push to remote; if HEAD diverges, perform `git pull --rebase`.
7. On merge conflicts that cannot be auto-resolved, halt and ping human operator.

## Commit Message Types

- `feat`: New feature + memory bank updates
- `fix`: Bug fix + memory bank updates
- `docs`: Documentation changes + memory bank updates
- `style`: Code style changes (formatting, missing semi-colons, etc) + memory bank updates
- `refactor`: Code change that neither fixes a bug nor adds a feature + memory bank updates
- `test`: Adding missing tests or correcting existing tests + memory bank updates
- `chore`: Changes to build process or auxiliary tools + memory bank updates

### Example Atomic Commit Messages

- `feat(auth): implement JWT authentication + update progress tracking`
- `fix(api): resolve user validation bug + document fix in activeContext`
- `refactor(db): optimize query performance + record pattern in systemPatterns`
- `test(ui): add component integration tests + update techContext with testing approach`

## Memory Bank File Templates

### Progress Entry Template
```markdown
## [Date] - [Task ID] - [Brief Description]

### Changes Made
- [Specific change 1]
- [Specific change 2]

### Technical Decisions
- [Decision 1 with rationale]
- [Decision 2 with rationale]

### Next Steps
- [Next immediate action]
- [Future considerations]

### Files Modified
- `path/to/file1.ts` - [what was changed]
- `path/to/file2.ts` - [what was changed]
```

### Active Context Entry Template
```markdown
## [Date] - [Context Type]

### Current Focus
[What we're currently working on]

### Key Decisions
- [Decision 1]
- [Decision 2]

### Blockers/Issues
- [Any current blockers]

### Next Actions
- [Immediate next steps]
```

### System Patterns Entry Template
```markdown
## [Date] - [Pattern Name]

### Pattern Description
[What this pattern does]

### Implementation Details
- [Key implementation points]
- [Code examples if relevant]

### Usage Guidelines
- [When to use this pattern]
- [When not to use this pattern]

### Related Patterns
- [Links to related patterns]
```

## Release Management

- Tag semantic versions for API changes
- Generate changelog from commit messages
- Create GitHub releases with artifacts
- Coordinate deployment to staging/production

## Quality Gates

- All tests must pass before commit
- No linting errors allowed
- Type checking must pass
- No TODO comments in production code
- Memory Bank files must be updated before commit

## Git Best Practices

### Branch Strategy
- `main` - production-ready code
- `develop` - integration branch
- `feature/*` - feature development
- `hotfix/*` - urgent production fixes

### Commit Guidelines
- One logical change per commit
- Clear, descriptive commit messages
- Reference task IDs when applicable
- Include Memory Bank updates

### Merge Strategy
- Squash and merge for feature branches
- Rebase before merging to main
- Require passing CI checks
- Code review approval required

> **Never** delete lines from Memory Bank files. Only append.
description:
globs:
alwaysApply: false
---
