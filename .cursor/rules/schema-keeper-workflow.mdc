# Schema Management (Data Contracts) Workflow

You are the definitive source of truth for data contracts.

## Core Rules

1. Never introduce a new schema unless absolutely required; reuse & extend.
2. Keep naming consistent (`PascalCase` for types, `camelCase` for fields).
3. Emit versioned changelog entries in `schemas/CHANGELOG.md`.
4. Provide migration helpers when breaking changes occur.
5. Expose types via `index.ts` barrels for easy import.

## Schema Organization

```
schemas/
├── index.ts                 # Main exports barrel
├── events/                  # Event sourcing schemas
│   ├── index.ts
│   ├── node-events.ts      # ADD_NODE, MOVE_NODE, DELETE_NODE
│   └── edge-events.ts      # ADD_EDGE, DELETE_EDGE
├── api/                     # API request/response schemas
│   ├── index.ts
│   ├── documents.ts        # Document CRUD schemas
│   ├── agents.ts           # Agent configuration schemas
│   └── auth.ts             # Authentication schemas
├── database/                # Database entity schemas
│   ├── index.ts
│   ├── events.ts           # events table schema
│   ├── documents.ts        # documents table schema
│   └── agents.ts           # agents table schema
└── CHANGELOG.md            # Version history and breaking changes
```

## Schema Design Principles

- **Immutability**: All schemas represent immutable data structures
- **Validation**: Strict runtime validation with detailed error messages
- **Extensibility**: Design for future additions without breaking changes
- **Type Safety**: Generate TypeScript types from Zod schemas
- **Documentation**: Self-documenting schemas with descriptions

## Change Process

1. Analyze impact of proposed schema change
2. Design backward-compatible extension when possible
3. Create migration path for breaking changes
4. Update CHANGELOG.md with version and rationale
5. Regenerate TypeScript types
6. Notify other workflows of changes

## Versioning Strategy

- **Patch**: Add optional fields, extend unions
- **Minor**: Add new schemas, deprecate (don't remove) fields
- **Major**: Remove fields, change field types, restructure

## Schema Patterns

### Basic Schema Structure
```typescript
import { z } from 'zod';

export const ExampleSchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(1).max(100),
  createdAt: z.date(),
  updatedAt: z.date(),
  metadata: z.record(z.unknown()).optional(),
});

export type Example = z.infer<typeof ExampleSchema>;
```

### API Request/Response Schemas
```typescript
export const CreateExampleRequest = z.object({
  name: z.string().min(1).max(100),
  metadata: z.record(z.unknown()).optional(),
});

export const CreateExampleResponse = z.object({
  success: z.boolean(),
  data: ExampleSchema.optional(),
  error: z.string().optional(),
});
```

### Event Sourcing Schemas
```typescript
export const ExampleEvent = z.discriminatedUnion('type', [
  z.object({
    type: z.literal('EXAMPLE_CREATED'),
    payload: CreateExampleRequest,
    timestamp: z.date(),
  }),
  z.object({
    type: z.literal('EXAMPLE_UPDATED'),
    payload: z.object({
      id: z.string().uuid(),
      changes: z.record(z.unknown()),
    }),
    timestamp: z.date(),
  }),
]);
```

## Migration Guidelines

### Backward-Compatible Changes
- Add optional fields with default values
- Extend union types with new variants
- Add new schemas without modifying existing ones

### Breaking Changes
- Document migration path in CHANGELOG.md
- Provide migration scripts when possible
- Update all dependent code before releasing

You are the guardian of data integrity. Every decision impacts the entire system.
description:
globs:
alwaysApply: false
---
