{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Project Structure and Development Environment",
        "description": "Set up the monorepo structure with React 18 + Vite frontend, Node.js 20 + Fastify backend, PostgreSQL 16 database, and Docker containerization",
        "details": "Create project structure with src/ (React frontend), api/ (Node.js backend), schemas/ (Zod schemas), docker/ (containers), and migrations/ (SQL). Initialize package.json with React 18.2+, Vite 5+, TypeScript 5+, Tailwind CSS 3.4+, Fastify 4.24+, Prisma 5.6+, Zod 3.22+. Set up Docker Compose with PostgreSQL 16, Node.js 20 Alpine images. Configure Vite dev server on port 3000, Fastify on 3001, PostgreSQL on 5432, Adminer on 8080. Install TipTap editor dependencies: @tiptap/react, @tiptap/pm, @tiptap/starter-kit.",
        "testStrategy": "Verify all services start correctly with docker-compose up, test API health endpoint, confirm frontend loads, validate database connection, run lint and typecheck scripts",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Design and Implement Database Schema",
        "description": "Create PostgreSQL schema for event-sourced architecture supporting chains, documents, agents, and version history",
        "details": "Design event-sourced schema with tables: events (id, aggregate_id, event_type, payload, timestamp), chains (id, name, canvas_state), documents (id, title, content, version), agents (id, name, prompt, model, tools), document_versions (id, document_id, content, created_at), edges (id, source_id, target_id, type). Use Prisma ORM with PostgreSQL provider. Implement append-only event log pattern for undo/redo capability. Add proper indexes on aggregate_id, timestamp, and foreign keys.",
        "testStrategy": "Write migration tests, validate schema constraints, test event sourcing patterns, verify foreign key relationships, benchmark query performance with sample data",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Core Zod Schemas and Data Validation",
        "description": "Create shared Zod schemas for API contracts, database models, and event sourcing following TDD methodology with test-first development for MVP scope",
        "status": "done",
        "dependencies": [
          2
        ],
        "priority": "high",
        "details": "Follow TDD workflow using test-runner sub-agent to create failing tests first, then schema-keeper for implementation. Define schemas in schemas/ directory with api/, database/, and events/ subdirectories: ChainSchema (id, name, nodes, edges), DocumentSchema (id, title, content, metadata), AgentSchema (id, name, prompt, model, tools), EventSchema (type, payload, timestamp). Use Zod 3.22+ with strict validation, custom error messages, and TypeScript inference. Create API request/response schemas and database entity schemas for MVP. Focus on core functionality without real-time communication features. Export types and validators. Complete with commit-bot for code commit and Memory Bank updates.",
        "testStrategy": "Start with unit tests UT-UT-01 for validators using test-runner sub-agent. Test schema validation edge cases and invalid inputs, verify TypeScript type inference, validate serialization/deserialization. Test API request/response schema validation and database entity validation for MVP scope.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create failing tests for core schemas (TDD)",
            "description": "Use test-runner sub-agent to create unit tests UT-UT-01 for schema validators before implementation",
            "status": "done",
            "dependencies": [],
            "details": "Create test files for ChainSchema, DocumentSchema, AgentSchema, and EventSchema validation. Test valid inputs, invalid inputs, edge cases, and TypeScript type inference. Tests should fail initially.\n<info added on 2025-08-05T12:30:06.088Z>\nSuccessfully completed comprehensive unit test creation for all 4 core Zod schemas with 170+ test cases total. Created test-driven foundation with proper test fixtures and validation coverage. Tests are failing as expected per TDD methodology - all imports fail because schemas don't exist yet (schemas/database/chain, schemas/database/document, schemas/database/agent, schemas/events/event). Ready for next phase where schema-keeper agent will implement actual Zod schemas to make tests pass.\n</info added on 2025-08-05T12:30:06.088Z>",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Set up schemas directory structure",
            "description": "Create schemas/ directory with api/, database/, and events/ subdirectories following project structure",
            "status": "done",
            "dependencies": [],
            "details": "Create schemas/api/, schemas/database/, and schemas/events/ directories. Set up index files for clean exports.",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement ChainSchema with schema-keeper",
            "description": "Create ChainSchema for chain data validation with id, name, nodes, edges properties",
            "status": "done",
            "dependencies": [],
            "details": "Use schema-keeper sub-agent to implement ChainSchema with Zod 3.22+. Include strict validation, custom error messages, and TypeScript inference.\n<info added on 2025-08-05T12:32:31.085Z>\nImplementation completed successfully. ChainSchema created in schemas/database/chain.ts with comprehensive Zod validation including all required and optional fields, nested NodeSchema and EdgeSchema validation, strict error handling, and TypeScript type inference. All 19 test cases passing with full coverage of edge cases and integration with database exports.\n</info added on 2025-08-05T12:32:31.085Z>",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement DocumentSchema with schema-keeper",
            "description": "Create DocumentSchema for document data validation with id, title, content, metadata properties",
            "status": "done",
            "dependencies": [],
            "details": "Use schema-keeper sub-agent to implement DocumentSchema with proper validation rules and TypeScript types.\n<info added on 2025-08-05T12:35:24.341Z>\n✅ COMPLETED: DocumentSchema implementation successful\n\nImplementation details:\n- Created `/Users/talchaimdamri/projects/chain of docs/COD_V01/schemas/database/document.ts`\n- All 24 test cases now passing (not 42 as originally mentioned - the test file contains 24 tests)\n- Schema includes all required validation rules:\n  * id: string with min length 1 (required)\n  * title: string with min length 1, max length 255 (required) \n  * content: string, can be empty or very large (required)\n  * metadata: flexible record using z.record(z.any()) (required)\n  * createdAt: optional Date field\n  * updatedAt: optional Date field\n- Uses .strict() for proper object validation\n- Includes descriptive error messages for all validations\n- Supports TypeScript type inference via z.infer<>\n- Exports both DocumentSchema and Document type\n- Handles all edge cases: null inputs, nested metadata, long content, empty content\n- Follows Zod 3.23+ best practices\n</info added on 2025-08-05T12:35:24.341Z>",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement AgentSchema with schema-keeper",
            "description": "Create AgentSchema for agent configuration validation with id, name, prompt, model, tools properties",
            "status": "done",
            "dependencies": [],
            "details": "Use schema-keeper sub-agent to implement AgentSchema with validation for agent properties and tool configurations.",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement EventSchema with schema-keeper",
            "description": "Create EventSchema for event sourcing validation with type, payload, timestamp properties",
            "status": "done",
            "dependencies": [],
            "details": "Use schema-keeper sub-agent to implement EventSchema for event-sourced state management with proper payload validation.",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Create API request/response schemas",
            "description": "Implement schemas for API endpoints in schemas/api/ directory for MVP scope",
            "status": "done",
            "dependencies": [],
            "details": "Create request and response schemas for core API endpoints needed for MVP, ensuring proper validation and type safety without real-time features.\n<info added on 2025-08-05T12:45:33.567Z>\nCOMPLETED: Created comprehensive API request/response schemas for MVP scope endpoints.\n\nIMPLEMENTATION DETAILS:\n✅ Created 5 API schema files in schemas/api/ directory:\n- common.ts: Response wrappers, pagination, error handling (shared patterns)\n- chains.ts: Chain CRUD + node/edge operations (20+ schemas)  \n- documents.ts: Document CRUD + content/metadata + search (25+ schemas)\n- agents.ts: Agent CRUD + tool management + validation/testing (30+ schemas)\n- events.ts: Event sourcing + batch operations + streaming + analytics (20+ schemas)\n\n✅ Key Features Implemented:\n- Standardized pagination and sorting for all list endpoints\n- Consistent success/error response wrappers\n- Comprehensive query parameter schemas with filtering\n- Request schemas that omit auto-generated fields (id, timestamps)\n- Summary schemas for performance (exclude large fields in lists)\n- Partial update schemas for selective field updates\n- Advanced operations (search, validation, testing, batch, streaming)\n\n✅ RESTful API Patterns:\n- GET /resource/:id (single item)\n- GET /resource (paginated list with filtering)\n- POST /resource (create)\n- PUT /resource/:id (full update)\n- PATCH /resource/:id (partial update)  \n- DELETE /resource/:id (remove)\n\n✅ All schemas reuse existing database schemas as base via .omit(), .pick(), .partial()\n✅ Full TypeScript type generation and export\n✅ Updated index.ts files for proper exports\n✅ Created CHANGELOG.md documenting v1.1.0 with API schemas\n✅ TypeScript compilation passes without errors\n✅ Validated schema patterns work correctly\n\nReady for backend-developer agent to implement Fastify route validation using these schemas.\n</info added on 2025-08-05T12:45:33.567Z>",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Verify all tests pass and commit",
            "description": "Use commit-bot to run tests, commit code, and update Memory Bank",
            "status": "done",
            "dependencies": [],
            "details": "Ensure all unit tests UT-UT-01 pass, run full test suite, commit schemas with proper git message, and update Memory Bank with implementation notes for MVP scope.",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "Build Fastify Backend API with JWT Authentication Placeholder",
        "description": "Set up Fastify server with routing, middleware, JWT placeholder, and basic CRUD endpoints following TDD methodology",
        "status": "done",
        "dependencies": [
          3
        ],
        "priority": "high",
        "details": "Follow TDD workflow: First use test-runner sub-agent to create failing integration tests (IT-EV-01, IT-EV-02, IT-EV-03, IT-AU-01) using Supertest. Then use backend-developer sub-agent for implementation. Initialize Fastify 4.24+ server with TypeScript in api/ directory with routes/, services/, middleware/ subdirectories. Implement Zod validation plugin, CORS middleware, and JSON schema validation. Create events API CRUD endpoints: GET/POST /api/events, PUT/DELETE /api/events/:id. Add JWT middleware placeholder using @fastify/jwt with httpOnly cookies. Set up error handling, request logging, and health check endpoint. Use Fastify's built-in validation with Zod schemas from task 3.",
        "testStrategy": "Start with test-runner sub-agent creating integration tests (IT-EV-01: GET /api/events, IT-EV-02: POST /api/events, IT-EV-03: Event validation, IT-AU-01: JWT authentication) using Supertest. Tests should fail initially, then pass after implementation. Verify CORS configuration, validate error handling, test request/response schemas.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Integration Tests with test-runner Sub-agent",
            "description": "Use test-runner sub-agent to create failing integration tests for events API",
            "status": "done",
            "dependencies": [],
            "details": "Create tests/integration/events.test.ts with IT-EV-01 (GET /api/events), IT-EV-02 (POST /api/events), IT-EV-03 (Event validation), IT-AU-01 (JWT authentication). Use Supertest for HTTP testing. Tests should initially fail as API doesn't exist yet.",
            "testStrategy": "Verify tests fail appropriately before implementation"
          },
          {
            "id": 2,
            "title": "Set up Fastify Server Structure with backend-developer Sub-agent",
            "description": "Create api/ directory structure and initialize Fastify server",
            "status": "done",
            "dependencies": [],
            "details": "Create api/ directory with routes/, services/, middleware/ subdirectories. Initialize Fastify 4.24+ server with TypeScript, Zod plugin, CORS middleware in api/server.ts. Set up proper project structure following existing patterns.",
            "testStrategy": "Verify server starts without errors and serves basic endpoints"
          },
          {
            "id": 3,
            "title": "Implement JWT Authentication Middleware Placeholder",
            "description": "Add JWT middleware using @fastify/jwt with httpOnly cookies",
            "status": "done",
            "dependencies": [],
            "details": "Install and configure @fastify/jwt plugin. Create middleware/auth.ts with JWT token validation placeholder. Set up httpOnly cookie handling for secure token storage. Implement authentication decorators for protected routes.",
            "testStrategy": "Verify JWT middleware is registered and IT-AU-01 test passes"
          },
          {
            "id": 4,
            "title": "Implement Events API CRUD Endpoints",
            "description": "Create events API routes with CRUD operations",
            "status": "done",
            "dependencies": [],
            "details": "Create routes/events.ts with GET/POST /api/events, PUT/DELETE /api/events/:id endpoints. Implement services/events.ts for business logic. Use Zod schemas from task 3 for request/response validation. Add proper error handling and logging.",
            "testStrategy": "Verify IT-EV-01, IT-EV-02, IT-EV-03 integration tests pass"
          },
          {
            "id": 5,
            "title": "Add Error Handling and Health Check",
            "description": "Implement global error handling and health check endpoint",
            "status": "done",
            "dependencies": [],
            "details": "Create middleware/errorHandler.ts for centralized error handling. Add GET /health endpoint for service monitoring. Implement request logging middleware. Ensure proper HTTP status codes and error responses.",
            "testStrategy": "Test error scenarios and verify health check endpoint responds correctly"
          },
          {
            "id": 6,
            "title": "Verify All Integration Tests Pass",
            "description": "Run all integration tests to ensure implementation is complete",
            "status": "done",
            "dependencies": [],
            "details": "Execute all integration tests created in subtask 1. Verify IT-EV-01, IT-EV-02, IT-EV-03, IT-AU-01 all pass. Fix any remaining issues to achieve green test suite.",
            "testStrategy": "All integration tests must pass for task completion"
          }
        ]
      },
      {
        "id": 5,
        "title": "Create SVG Canvas Component with Pan/Zoom/Grid",
        "description": "Build the main canvas component with SVG rendering, pan/zoom controls, and 8px background grid using TDD methodology",
        "status": "done",
        "dependencies": [
          4
        ],
        "priority": "high",
        "details": "Follow TDD workflow: start with test-runner sub-agent creating E2E tests (E2E-CV-01, E2E-CV-02) using Playwright, then ui-developer sub-agent implements React component. Create Canvas component in src/components/canvas/ directory using SVG with viewBox for pan/zoom. Implement mouse/touch events for dragging, wheel events for zoom, keyboard shortcuts for navigation. Add 8px dotted grid pattern as SVG defs. Integrate event sourcing for state management instead of plain React hooks. Implement bounds checking and smooth animations with CSS transitions. Support zoom range 0.1x to 5x, pan boundaries based on content.",
        "testStrategy": "Start with E2E tests using Playwright (E2E-CV-01, E2E-CV-02 from comprehensive test plan), then unit tests for pan/zoom calculations, test mouse/touch interactions, verify grid rendering, test keyboard shortcuts, performance test with large viewports, validate event sourcing integration",
        "subtasks": [
          {
            "id": 1,
            "title": "Create E2E Tests for Canvas Component (test-runner)",
            "description": "Use test-runner sub-agent to create comprehensive E2E tests using Playwright",
            "status": "done",
            "dependencies": [],
            "details": "Implement E2E-CV-01 and E2E-CV-02 test scenarios from the comprehensive test plan. Create Playwright tests that verify canvas initialization, pan/zoom functionality, grid rendering, mouse/touch interactions, and keyboard shortcuts. Set up test data and mock scenarios for canvas operations.",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Set up Canvas Component Structure (ui-developer)",
            "description": "Create the basic Canvas component structure in src/components/canvas/",
            "status": "done",
            "dependencies": [],
            "details": "Use ui-developer sub-agent to create Canvas component directory structure. Set up Canvas.tsx, CanvasGrid.tsx, and supporting files. Implement basic SVG structure with viewBox configuration. Create TypeScript interfaces for canvas state and props.",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Event Sourcing Integration (ui-developer)",
            "description": "Integrate event sourcing for canvas state management",
            "status": "done",
            "dependencies": [],
            "details": "Replace plain React hooks with event sourcing pattern for canvas transform, zoom level, and selection state. Create canvas events (PAN_CANVAS, ZOOM_CANVAS, SELECT_ELEMENT) and corresponding reducers. Implement undo/redo functionality for canvas operations.",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Pan/Zoom Controls (ui-developer)",
            "description": "Add mouse/touch pan and wheel zoom functionality",
            "status": "done",
            "dependencies": [],
            "details": "Implement mouse drag for panning, wheel events for zooming, touch gestures for mobile. Add zoom range limits (0.1x to 5x), pan boundary constraints, and smooth CSS transitions. Handle viewBox transformations and coordinate system conversions.",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create 8px Background Grid (ui-developer)",
            "description": "Implement SVG background grid pattern",
            "status": "done",
            "dependencies": [],
            "details": "Create 8px dotted grid pattern using SVG defs and pattern elements. Ensure grid scales properly with zoom levels and maintains visual consistency. Make grid toggleable and responsive to canvas transformations.",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Add Keyboard Navigation (ui-developer)",
            "description": "Implement keyboard shortcuts for canvas navigation",
            "status": "done",
            "dependencies": [],
            "details": "Add keyboard shortcuts for pan (arrow keys), zoom (+ / -), reset view (R), and other canvas operations. Implement proper focus management and accessibility features. Handle keyboard event bubbling and conflicts.",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Verify E2E Test Coverage",
            "description": "Ensure all implemented features pass E2E tests",
            "status": "done",
            "dependencies": [],
            "details": "Run E2E-CV-01 and E2E-CV-02 tests against implemented Canvas component. Verify all pan/zoom functionality, grid rendering, keyboard shortcuts, and event sourcing integration work as expected. Fix any failing test scenarios.",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Document and Agent Node Components",
        "description": "Create draggable SVG node components for documents and agents with visual styling",
        "details": "Build DocumentNode and AgentNode as SVG components with distinct visual styles. DocumentNode: rounded rectangle, document icon, title text. AgentNode: circular/hexagonal shape, agent icon, model indicator. Implement drag behavior with SVG transform, collision detection, and snap-to-grid. Add selection states, hover effects, and connection points. Use SVG foreignObject for text overflow handling.",
        "testStrategy": "Test drag interactions, verify visual styling, test selection states, validate SVG rendering across browsers, test node positioning and collision detection",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Build Edge Connection System",
        "description": "Implement SVG edge rendering and automatic connection creation between nodes",
        "details": "Create Edge component using SVG path with bezier curves or straight lines. Implement automatic edge creation when DocumentNode is dropped on AgentNode. Add connection points/anchors on nodes, visual feedback during drag operations. Support different edge types: document-to-agent, agent-to-document. Include arrow markers, edge labels, and selection highlighting. Handle edge routing around nodes.",
        "testStrategy": "Test drag-and-drop edge creation, verify SVG path rendering, test edge selection and deletion, validate connection point positioning, test edge routing algorithms",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Create Left Sidebar Object Library",
        "description": "Build collapsible sidebar with chains, documents, and agents lists at 320px fixed width",
        "details": "Create collapsible sidebar component with three sections: Chains, Documents, Agents. Fixed 320px width with resize handle, toggle collapse/expand. Implement virtualized lists for performance with large datasets. Add search/filter functionality, drag-and-drop from sidebar to canvas. Use React Virtual or @tanstack/react-virtual for list virtualization. Include icons, thumbnails, and metadata display.",
        "testStrategy": "Test sidebar collapse/expand, verify drag-and-drop from sidebar, test virtualized list performance, validate search functionality, test responsive behavior",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Right Inspector Panel for Agent Configuration",
        "description": "Build context-sensitive inspector panel that opens when an AgentNode is selected",
        "details": "Create inspector panel component that slides in from right when AgentNode is selected. Display agent properties: name, prompt, model selection, tools configuration. Include form controls with real-time validation using React Hook Form and Zod schemas. Add auto-generate prompt button, model dropdown (GPT-4, Claude, etc.), and tools checklist. Panel should be responsive and scrollable.",
        "testStrategy": "Test panel open/close behavior, verify form validation, test model selection dropdown, validate real-time updates, test panel responsiveness",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Build TipTap Document Editor Modal",
        "description": "Create rich text editor modal with TipTap, version history, and document rails following TDD methodology",
        "status": "done",
        "dependencies": [
          3
        ],
        "priority": "high",
        "details": "Follow TDD workflow: First use test-runner sub-agent to create failing E2E tests (E2E-DV-01) and unit tests for document editing functionality. Then use ui-developer sub-agent for implementation. Create TipTap editor modal in src/components/modals/ directory at 70% width with maximize option. Configure TipTap with StarterKit, heading, bullet list, ordered list, code block extensions. Add custom toolbar with formatting options, Ask Agent button, Undo/Redo, Save Version. Implement document rails showing upstream/downstream connections. Integrate with event sourcing system for document change tracking. Use @tiptap/react 2.1+, @tiptap/extension-* packages for features.",
        "testStrategy": "Start with test-runner sub-agent creating E2E tests (E2E-DV-01) and unit tests for document editing. Tests should fail initially, then pass after implementation. Test editor functionality, verify modal behavior, test toolbar actions, validate version saving, test document rails display, verify undo/redo functionality, test event sourcing integration for document changes",
        "subtasks": [
          {
            "id": 1,
            "title": "Create failing E2E and unit tests for document editor",
            "description": "Use test-runner sub-agent to create comprehensive test suite",
            "status": "done",
            "dependencies": [],
            "details": "Create E2E test E2E-DV-01 for document editing workflow including modal opening, text editing, formatting, version saving, and document rails interaction. Add unit tests for TipTap editor configuration, toolbar functionality, and event sourcing integration. Tests should fail initially to follow TDD methodology.",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Set up TipTap modal component structure",
            "description": "Create modal component foundation in src/components/modals/",
            "status": "done",
            "dependencies": [],
            "details": "Use ui-developer sub-agent to create DocumentEditorModal component with proper modal dialog structure, 70% width sizing, maximize functionality, and modal overlay behavior. Set up component file structure and basic props interface.",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Configure TipTap editor with required extensions",
            "description": "Implement TipTap editor with StarterKit and additional extensions",
            "status": "done",
            "dependencies": [],
            "details": "Configure TipTap editor with StarterKit, heading, bullet list, ordered list, code block extensions. Set up @tiptap/react 2.1+ with proper TypeScript integration and editor instance management.",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Build custom toolbar with formatting controls",
            "description": "Create toolbar with formatting options and special buttons",
            "status": "done",
            "dependencies": [],
            "details": "Implement custom toolbar with text formatting options (bold, italic, headings), Ask Agent button, Undo/Redo controls, and Save Version functionality. Ensure toolbar is responsive and accessible.",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement document rails for upstream/downstream connections",
            "description": "Add document rails showing chain connections",
            "status": "done",
            "dependencies": [],
            "details": "Create document rails component showing upstream and downstream document connections. Display visual indicators of document relationships and allow navigation between connected documents.",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Integrate event sourcing for document changes",
            "description": "Connect editor to event sourcing system",
            "status": "done",
            "dependencies": [],
            "details": "Implement event sourcing integration to track all document changes. Capture edit events, version snapshots, and maintain immutable change history for undo/redo functionality and version management.",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Verify all tests pass and functionality works",
            "description": "Ensure TDD cycle completion with passing tests",
            "status": "done",
            "dependencies": [],
            "details": "Run all E2E and unit tests to verify they now pass. Test complete document editor functionality including modal behavior, editing capabilities, version history, and document rails integration.",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 11,
        "title": "Implement Document Version History and Undo/Redo",
        "description": "Build version control system with event sourcing for document changes and UI controls following TDD methodology",
        "status": "done",
        "dependencies": [
          10,
          2
        ],
        "priority": "high",
        "details": "Following TDD approach, implement event-sourced version history storing document change events with immutable change history. Create version list UI showing timestamps, change descriptions, and diff previews. Add undo/redo functionality using command pattern with event replay. Store events in PostgreSQL with proper indexing. Implement diff algorithm for text comparison using diff-match-patch library. Add version restoration and branching capabilities. Implementation follows sub-agent workflow: test-runner creates comprehensive tests first, then backend-developer and ui-developer implement features.",
        "testStrategy": "Start with test-runner sub-agent creating unit tests (UT-UR-01, UT-UR-02, UT-SS-01) and E2E tests (E2E-VS-01, E2E-VS-02) from comprehensive test plan. Test version creation and restoration, verify undo/redo functionality, test diff calculation, validate event sourcing integrity, test version list UI",
        "subtasks": [
          {
            "id": 1,
            "title": "Create comprehensive test suite for version history system",
            "description": "Use test-runner sub-agent to create unit tests and E2E tests for version control functionality",
            "status": "done",
            "dependencies": [],
            "details": "Create unit tests UT-UR-01 (undo/redo operations), UT-UR-02 (version restoration), UT-SS-01 (event sourcing integrity). Create E2E tests E2E-VS-01 (version list UI interactions), E2E-VS-02 (full version history workflow). Tests should cover event creation, version restoration, diff calculation, and UI interactions.",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement event sourcing backend with PostgreSQL storage",
            "description": "Use backend-developer sub-agent to implement event-sourced version control system",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Implement immutable event store in PostgreSQL with proper indexing. Create event models for document changes, command pattern for undo/redo operations, and event replay functionality. Add API endpoints for version history retrieval, diff calculation using diff-match-patch library, and version restoration.",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Build version history UI components and controls",
            "description": "Use ui-developer sub-agent to create version list UI and undo/redo controls",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "Create version history panel showing timestamps, change descriptions, and diff previews. Implement undo/redo buttons with keyboard shortcuts. Add version restoration interface and diff visualization. Ensure responsive design and proper state management for version operations.",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Integrate version history with document editing system",
            "description": "Connect version control system with existing document components",
            "status": "done",
            "dependencies": [
              3
            ],
            "details": "Integrate event sourcing with document editing operations. Ensure all document changes trigger version events. Connect undo/redo controls to document state management. Add version branching capabilities and conflict resolution.",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 12,
        "title": "Create Agent Editor Popup with Model Selection",
        "description": "Build agent configuration popup with prompt editing, model selection, and tools configuration",
        "details": "Create popup overlay for agent editing with prompt textarea, model dropdown (OpenAI GPT-4, Claude 3.5, etc.), and tools selection. Add auto-generate prompt functionality using LLM API. Include agent testing interface with sample inputs. Implement form validation with Zod schemas. Add agent templates and prompt library. Support custom model parameters (temperature, max tokens).",
        "testStrategy": "Test popup display and form functionality, verify model selection, test auto-generate prompt feature, validate form validation, test agent templates",
        "priority": "medium",
        "dependencies": [
          9
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Agent Editor Popup UI Layout",
            "description": "Create the visual and interactive layout for the agent editor popup, including prompt textarea, model selection dropdown, tools configuration, and areas for agent templates and prompt library.",
            "dependencies": [],
            "details": "Define the popup overlay structure using React components. Ensure clear separation for prompt editing, model selection (supporting models like OpenAI GPT-4, Claude 3.5, etc.), tools selection, and template/prompt library access. Include UI elements for custom model parameters (temperature, max tokens).",
            "status": "done",
            "testStrategy": "Verify popup renders correctly, all UI elements are present, and layout adapts to different screen sizes."
          },
          {
            "id": 2,
            "title": "Implement Model Selection and Custom Parameter Controls",
            "description": "Develop the model dropdown and controls for custom model parameters, ensuring support for multiple LLM providers and dynamic parameter fields.",
            "dependencies": [
              "12.1"
            ],
            "details": "Integrate a dropdown for model selection with options for OpenAI GPT-4, Claude 3.5, and others. Dynamically display and validate custom parameter fields (e.g., temperature, max tokens) based on selected model. Ensure compatibility with available API schemas.\n<info added on 2025-08-07T09:20:32.554Z>\n✅ Completed Model Selection and Parameter Controls Implementation\n\nWhat was implemented:\n- Comprehensive model selection dropdown with optgroups for OpenAI, Anthropic, and Local models\n- Dynamic parameter controls for temperature (0-2 range) and max tokens (1-200000 range)\n- Real-time validation with error messages for all parameter inputs\n- Model-specific default parameter values that update when model changes\n- Form validation ensuring all required fields are properly filled\n\nKey Features:\n- Model dropdown includes GPT-4, GPT-4 Turbo, GPT-3.5 Turbo, Claude 3 Sonnet, Claude 3 Haiku, and local models\n- Temperature control with step 0.1 precision and 0-2 range validation\n- Max tokens control with 1-200000 range validation\n- Automatic parameter updates when switching between models\n- Comprehensive test coverage for all model selection and parameter functionality\n\nTest Results: All 32 tests passing, including model switching, parameter validation, and form interactions.\n\nThe implementation is complete and ready for the next subtask.\n</info added on 2025-08-07T09:20:32.554Z>",
            "status": "done",
            "testStrategy": "Test model switching, parameter input validation, and correct parameter mapping for each model."
          },
          {
            "id": 3,
            "title": "Integrate Prompt Auto-Generation and Prompt Library",
            "description": "Add functionality to auto-generate prompts using an LLM API and provide access to a prompt library and agent templates.",
            "dependencies": [
              "12.1"
            ],
            "details": "Implement a button to trigger prompt auto-generation via API call to the selected LLM. Integrate a searchable prompt library and agent templates for quick insertion or replacement of prompts. Ensure seamless interaction between manual editing and library/template selection.\n<info added on 2025-08-07T10:16:21.398Z>\n✅ COMPLETED - Prompt Auto-Generation and Prompt Library Integration\n\nWhat was implemented:\n1. PromptLibraryService - Created a comprehensive service class with:\n   - Pre-defined prompt templates across multiple categories (Document Processing, Code & Development, Data Analysis, Research, Creative Content)\n   - Search and filtering capabilities by category, model, tags, and tools\n   - Methods for adding/removing custom prompts\n   - Singleton pattern for consistent state management\n\n2. PromptLibraryModal - Built a full-featured UI component with:\n   - Search functionality with real-time filtering\n   - Category, model, tag, and tool filters\n   - Prompt preview and selection interface\n   - Proper accessibility with htmlFor labels\n   - Responsive design with sidebar filters and main content area\n\n3. Enhanced AgentEditorModal - Integrated the prompt library:\n   - Added \"Library\" button to open PromptLibraryModal\n   - Implemented prompt selection callback to update agent configuration\n   - Enhanced auto-generation with more detailed, context-aware prompts\n   - Improved prompt generation based on agent name and selected tools\n\n4. Comprehensive Testing - Created thorough test coverage:\n   - Unit tests for PromptLibraryService functionality\n   - Component tests for PromptLibraryModal UI interactions\n   - Integration tests for AgentEditorModal with prompt library\n   - Fixed all test failures and ensured 100% pass rate\n\nKey Features:\n- Smart Prompt Generation: Auto-generates detailed prompts based on agent name and tools\n- Template Library: 7 pre-defined prompt templates across different domains\n- Advanced Filtering: Search by text, filter by category, model, tags, and tools\n- Seamless Integration: One-click prompt application from library to agent editor\n- Accessibility: Proper ARIA labels and keyboard navigation support\n\nTechnical Implementation:\n- Used singleton pattern for PromptLibraryService to maintain state\n- Implemented proper TypeScript interfaces for type safety\n- Added comprehensive error handling and loading states\n- Created reusable components with proper prop interfaces\n- Maintained consistent styling with Tailwind CSS\n\nTest Results: ✅ All 235 tests passing\n</info added on 2025-08-07T10:16:21.398Z>",
            "status": "done",
            "testStrategy": "Test prompt auto-generation for different models, verify prompt library search and insertion, and ensure prompt field updates correctly."
          },
          {
            "id": 4,
            "title": "Develop Agent Testing Interface with Sample Inputs",
            "description": "Create an embedded interface within the popup for testing agent configurations using sample inputs and displaying model responses.",
            "dependencies": [
              "12.2",
              "12.3"
            ],
            "details": "Allow users to input sample data and invoke the configured agent (prompt, model, tools) to preview responses. Display results, including error handling for invalid configurations or API failures.",
            "status": "done",
            "testStrategy": "Test agent execution with various sample inputs, verify correct response rendering, and handle error scenarios gracefully."
          },
          {
            "id": 5,
            "title": "Implement Form Validation with Zod Schemas",
            "description": "Apply Zod schemas to validate all agent configuration fields, including prompt, model selection, tools, and custom parameters.",
            "dependencies": [
              "12.2",
              "12.3"
            ],
            "details": "Define Zod schemas for the agent configuration form. Integrate validation logic to provide real-time feedback and prevent submission of invalid configurations. Ensure validation covers all required fields and model-specific constraints.\n<info added on 2025-08-07T16:02:21.341Z>\nAgentEditorFormSchema and AgentValidationService have been fully implemented, providing comprehensive Zod-based validation for all agent configuration fields, including real-time feedback, custom error messages, and model-specific constraints. The AgentEditorModal now features integrated validation with visual error indicators, disabled save functionality when invalid, and an error summary. Extensive unit and component tests ensure robust validation coverage and type safety throughout the form.\n</info added on 2025-08-07T16:02:21.341Z>",
            "status": "done",
            "testStrategy": "Test form validation for missing, invalid, or out-of-range values; verify error messages and form submission blocking."
          }
        ]
      },
      {
        "id": 13,
        "title": "Implement Manual Agent Execution with Streaming Output",
        "description": "Build agent run system with LLM API integration and real-time output streaming following TDD methodology",
        "status": "done",
        "dependencies": [
          12,
          4
        ],
        "priority": "high",
        "details": "Following TDD approach, implement agent execution engine calling OpenAI API with streaming responses. Start with test-runner sub-agent creating comprehensive unit and integration tests. Use backend-developer sub-agent for LLM API integration with streaming support, error handling, and timeout management. Use ui-developer sub-agent for real-time output display component with SSE or WebSocket connection. Support multiple LLM providers (OpenAI, Anthropic) with adapter pattern. Implement rate limiting, request queuing, and execution status tracking. Store execution results in database with proper indexing.",
        "testStrategy": "Start with test-runner sub-agent creating unit tests (UT-AR-01, UT-AR-02) and integration tests (IT-AG-01, IT-AG-02) from comprehensive test plan. Test LLM API integration, verify streaming output display, test error handling and timeout scenarios, validate execution status tracking, test multiple model providers, performance test with concurrent runs and rate limiting",
        "subtasks": [
          {
            "id": 1,
            "title": "Create unit tests for agent execution engine (UT-AR-01, UT-AR-02)",
            "description": "Use test-runner sub-agent to create comprehensive unit tests for agent execution logic",
            "status": "done",
            "dependencies": [],
            "details": "Create failing unit tests for agent execution engine including LLM API calls, response handling, error scenarios, and timeout management. Tests should cover execution state transitions, streaming response parsing, and provider adapter pattern.",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create integration tests for agent system (IT-AG-01, IT-AG-02)",
            "description": "Use test-runner sub-agent to create integration tests for complete agent execution flow",
            "status": "done",
            "dependencies": [],
            "details": "Create integration tests covering end-to-end agent execution, database storage of results, streaming output delivery, and multi-provider support. Include tests for rate limiting and concurrent execution scenarios.\n<info added on 2025-08-07T17:13:21.367Z>\n✅ COMPLETED: Created comprehensive integration tests for agent execution system\n\nTest Coverage Achieved:\n- IT-AG-01: End-to-End Agent Execution Flow (4 tests)\n- IT-AG-02: Streaming Output Integration (3 tests)\n- IT-AG-03: Database Integration (2 tests)\n- IT-AG-04: Multi-Provider Support (2 tests)\n- IT-AG-05: Rate Limiting Integration (2 tests)\n- IT-AG-06: Error Handling Integration (3 tests)\n- IT-AG-07: Performance Integration (2 tests)\n\nKey Features Tested:\n- Concurrent agent executions with unique IDs\n- Streaming output with proper chunk handling\n- Database storage readiness\n- Multi-provider support\n- Rate limiting scenarios\n- Error handling for network timeouts and invalid configurations\n- Performance benchmarks and memory efficiency\n\nTest Results: All 18 integration tests passing\n\nTechnical Implementation:\n- Fixed unique ID generation using timestamp + counter pattern\n- Comprehensive error handling for streaming scenarios\n- Database integration ready for real implementation\n- Performance testing with large inputs and concurrent requests\n</info added on 2025-08-07T17:13:21.367Z>",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement LLM API integration with streaming support",
            "description": "Use backend-developer sub-agent to implement LLM provider adapters and streaming API",
            "status": "done",
            "dependencies": [],
            "details": "Implement OpenAI and Anthropic API adapters with streaming response handling. Create execution engine with proper error handling, timeout management, and status tracking. Add rate limiting and request queuing system.\n<info added on 2025-08-07T17:19:28.883Z>\n✅ COMPLETED: Implemented LLM API integration with streaming support\n\n**Key Features Implemented:**\n- ✅ OpenAI Provider with streaming support\n- ✅ Anthropic Provider with streaming support  \n- ✅ Mock Provider for testing\n- ✅ LLM Provider Manager with rate limiting\n- ✅ Error handling and timeout management\n- ✅ Request queuing system\n\n**Technical Implementation:**\n- **OpenAI Provider**: Full streaming support with proper chunk parsing\n- **Anthropic Provider**: Complete API integration with streaming\n- **Mock Provider**: Realistic simulation for testing\n- **Provider Manager**: Centralized provider management with rate limiting (10 requests/minute)\n- **Error Handling**: Comprehensive error handling for network timeouts, API errors, and invalid configurations\n- **Timeout Management**: Configurable timeouts (default 30s) with AbortSignal support\n\n**Integration with Agent Execution Service:**\n- ✅ Updated agent execution service to use real LLM providers\n- ✅ Automatic provider selection based on model name\n- ✅ Fallback to mock provider when API keys not available\n- ✅ All 19 unit tests passing ✅\n\n**API Support:**\n- OpenAI: gpt-4, gpt-4-turbo, gpt-4o, gpt-4o-mini, gpt-3.5-turbo, gpt-3.5-turbo-16k\n- Anthropic: claude-3-opus, claude-3-sonnet, claude-3-haiku, claude-2.1, claude-2.0, claude-instant-1.2\n- Mock: mock-model-1, mock-model-2\n\n**Rate Limiting & Performance:**\n- Provider-level rate limiting (10 requests/minute per provider)\n- User-level rate limiting support\n- Concurrent execution handling\n- Memory-efficient streaming with proper cleanup\n</info added on 2025-08-07T17:19:28.883Z>",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Build real-time output streaming UI component",
            "description": "Use ui-developer sub-agent to create streaming output display with SSE/WebSocket",
            "status": "done",
            "dependencies": [],
            "details": "Create run window component displaying real-time agent output using Server-Sent Events or WebSocket connection. Include execution status indicators, progress tracking, and error display with proper reconnection handling.\n<info added on 2025-08-07T17:24:02.392Z>\n✅ COMPLETED: Built real-time output streaming UI component\n\nKey Features Implemented:\n- Real-time streaming output display using Server-Sent Events (SSE) for efficient, low-latency updates\n- Execution status indicators for all lifecycle states: idle, connecting, streaming, completed, and error\n- Visual progress tracking with dynamic indicators\n- Robust error display with user-friendly messages and automatic reconnection support\n- Auto-scroll to bottom to ensure latest output is always visible\n- Stop and Clear controls for user interaction\n- Token usage and model information display for transparency\n- Execution timing and duration tracking for performance insights\n\nTechnical Implementation:\n- StreamingOutput: Fully featured React component written in TypeScript\n- SSE protocol for real-time streaming, leveraging EventSource API for frontend connectivity\n- Comprehensive state management for execution lifecycle and status transitions\n- Graceful error handling and reconnection logic\n- Modern, responsive UI/UX with Tailwind CSS\n- AbortController integration for request cancellation and stop functionality\n\nAPI Integration:\n- Fastify-based backend endpoints supporting both streaming and non-streaming execution\n- POST /api/agents/stream for SSE-based streaming execution\n- POST /api/agents/execute for traditional execution\n- GET /api/agents/:id/status for real-time status polling\n- GET /api/agents/providers for listing available providers\n\nDemo Component:\n- StreamingDemo: Interactive demo with input panel, real-time output, and feature showcase\n\nTesting:\n- All unit tests passing with comprehensive coverage for all component states, including error and edge cases\n- Mock fetch integration for isolated testing\n\nFeatures:\n- Real-time character-by-character streaming\n- Execution status with visual indicators\n- Token usage and model tracking\n- Execution timing and duration\n- Stop/Clear functionality\n- Error handling and display\n- Auto-scroll to bottom\n- Responsive design\n</info added on 2025-08-07T17:24:02.392Z>",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement execution result storage and retrieval",
            "description": "Create database schema and services for storing agent execution results",
            "status": "done",
            "dependencies": [],
            "details": "Design and implement database schema for storing execution results, logs, and metadata. Create services for result persistence and retrieval with proper indexing for performance.\n<info added on 2025-08-07T17:29:36.992Z>\nExecution result storage and retrieval system fully implemented and tested. Database schema includes AgentExecution, ExecutionLog, ExecutionChunk, and ExecutionStats models with comprehensive indexing, foreign key relationships, and cascading deletes. Services provide complete CRUD operations, real-time status tracking, streaming chunk storage, statistical aggregation, and automated cleanup. All service methods covered by unit tests with mock Prisma client, ensuring robust error handling and edge case coverage. Database migration applied successfully with all constraints and performance optimizations in place.\n</info added on 2025-08-07T17:29:36.992Z>",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 14,
        "title": "Build Chain State Management and Canvas Persistence",
        "description": "Implement canvas state management, auto-save functionality, and chain persistence",
        "details": "Create Redux Toolkit or Zustand store for canvas state management. Implement auto-save with debounced API calls every 30 seconds. Store canvas state: node positions, zoom level, selections, edge connections. Add chain loading/saving with optimistic updates. Implement state rehydration on page refresh. Handle concurrent modifications with conflict resolution.\n<info added on 2025-08-07T22:42:26.342Z>\nImplementation plan and progress log:\n- Added Zustand-based canvas store `useCanvasStore` managing nodes, edges, viewport (x,y,zoom), and selection with setters and clear.\n- Added persistence helpers: localStorage save/load (`saveCanvasState`, `saveCanvasStateDebounced`) with debounce at 1s.\n- Unit tests added for store and persistence; passing.\nNext steps: integrate store with existing canvas components (`Canvas`, `NodeCanvas`) to read/write state and wire debounced auto-save on changes; implement load-on-init and rehydration on refresh; add conflict resolution placeholder for future server sync. After integration, add integration tests to verify rehydration/auto-save.\n</info added on 2025-08-07T22:42:26.342Z>",
        "testStrategy": "Test state persistence and rehydration, verify auto-save functionality, test concurrent modification handling, validate canvas state integrity, test optimistic updates",
        "priority": "medium",
        "dependencies": [
          7,
          4
        ],
        "status": "in-progress",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Implement Node Context Menus and Interaction System",
        "description": "Add long-press context menus, double-click handlers, and node interaction system",
        "details": "Implement long-press detection for AgentNode showing Edit/Delete context menu. Add double-click handler for DocumentNode opening editor modal. Create context menu component with proper positioning and click-outside handling. Add keyboard shortcuts for common actions (Delete, Copy, Paste). Implement multi-selection with Ctrl+click and rectangle selection. Add node grouping and bulk operations.",
        "testStrategy": "Test long-press detection on different devices, verify context menu positioning, test double-click behavior, validate keyboard shortcuts, test multi-selection functionality",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Long-Press Detection and Context Menu for AgentNode",
            "description": "Detect long-press events on AgentNode components and display a context menu with Edit and Delete options, ensuring proper menu positioning and click-outside handling.",
            "dependencies": [],
            "details": "Integrate long-press gesture detection for AgentNode. Render a context menu component at the correct position relative to the node. Ensure the menu closes when clicking outside or after an action is selected.",
            "status": "done",
            "testStrategy": "Test long-press detection on both desktop and touch devices. Verify context menu appears at correct position and closes on outside click or action selection."
          },
          {
            "id": 2,
            "title": "Add Double-Click Handler for DocumentNode to Open Editor Modal",
            "description": "Implement double-click event handling on DocumentNode components to open an editor modal for document editing.",
            "dependencies": [],
            "details": "Attach double-click event listeners to DocumentNode. Trigger the opening of a modal editor with the document's content when double-clicked. Ensure modal closes and updates are saved appropriately.",
            "status": "done",
            "testStrategy": "Test double-click behavior on DocumentNode. Verify editor modal opens with correct content and closes properly, saving changes as expected."
          },
          {
            "id": 3,
            "title": "Develop Reusable Context Menu Component with Positioning and Dismissal",
            "description": "Create a reusable context menu component that can be positioned dynamically and supports click-outside dismissal for use across node types.",
            "dependencies": [
              "15.1",
              "15.2"
            ],
            "details": "Design a context menu component that accepts position and menu items as props. Implement logic for dynamic positioning based on trigger event. Add global event listeners to handle click-outside and escape key for dismissal.",
            "status": "done",
            "testStrategy": "Verify context menu positions correctly relative to trigger. Test click-outside and escape key dismissal. Ensure menu is reusable for different node types."
          },
          {
            "id": 4,
            "title": "Implement Keyboard Shortcuts for Node Actions",
            "description": "Add keyboard shortcuts for common node actions such as Delete, Copy, and Paste, ensuring accessibility and multi-platform support.",
            "dependencies": [],
            "details": "Register global and context-sensitive keyboard shortcuts for node actions. Ensure shortcuts work with multi-selection and do not conflict with browser/system defaults.\n<info added on 2025-08-07T22:27:38.553Z>\nImplemented canvas-level keyboard shortcuts: pressing Delete or Backspace triggers onDeleteSelection, Cmd/Ctrl+C triggers onCopySelection, and Cmd/Ctrl+V triggers onPaste. Added optional props to the Canvas component to enable or customize these shortcuts, integrated a keydown handler with meta/ctrl key detection, and created unit tests to verify these behaviors alongside existing navigation shortcuts. All new tests pass.\n</info added on 2025-08-07T22:27:38.553Z>",
            "status": "done",
            "testStrategy": "Test keyboard shortcuts for Delete, Copy, and Paste on selected nodes. Validate correct actions are triggered and shortcuts do not interfere with other app or system shortcuts."
          },
          {
            "id": 5,
            "title": "Enable Multi-Selection, Rectangle Selection, Node Grouping, and Bulk Operations",
            "description": "Implement multi-selection of nodes using Ctrl+click and rectangle (marquee) selection, support node grouping, and enable bulk operations via context menu or shortcuts.",
            "dependencies": [],
            "details": "Allow users to select multiple nodes with Ctrl+click and by dragging a selection rectangle. Implement grouping of selected nodes and provide bulk actions (e.g., Delete, Copy) in context menu and via shortcuts.\n<info added on 2025-08-07T22:28:54.021Z>\nWire rectangle selection bounds to node hit-testing: when the selection rectangle changes, compute which nodes intersect with the normalized bounds and update their selection state accordingly. Ensure that selected nodes are visually highlighted and that group and bulk actions (Delete, Copy) become enabled in the context menu and via keyboard shortcuts when multiple nodes are selected. Add unit tests to verify correct node selection toggling, group action enablement, and state clearing after selection.\n</info added on 2025-08-07T22:28:54.021Z>",
            "status": "done",
            "testStrategy": "Test multi-selection with Ctrl+click and rectangle selection. Verify grouping and bulk operations work as expected for selected nodes."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-08-05T03:13:56.307Z",
      "updated": "2025-08-07T22:39:32.493Z",
      "description": "Tasks for master context"
    }
  }
}